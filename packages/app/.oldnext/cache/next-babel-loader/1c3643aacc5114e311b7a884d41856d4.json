{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { AxisBottom, AxisLeft } from \"@visx/axis\";\nimport { GridRows } from \"@visx/grid\";\nimport { Group } from \"@visx/group\";\nimport { scaleBand, scaleLinear } from \"@visx/scale\";\nimport { BarRounded } from \"@visx/shape\";\nimport { defaultStyles, useTooltip, useTooltipInPortal } from \"@visx/tooltip\";\nimport { range } from \"lodash\";\nimport React, { useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { formatWaitTime } from \"../../../utils/TimeUtil\";\nimport { formatDateHour } from \"./FormatDateHour\";\nlet tooltipTimeout;\n\nconst tooltipStyles = _objectSpread(_objectSpread({}, defaultStyles), {}, {\n  minWidth: 60,\n  backgroundColor: \"rgba(0,0,0,0.9)\",\n  color: \"white\"\n}); // The distance in pixels from the left side of the component to the origin of the graph\n\n\nconst LEFT_MARGIN = 45; // The distance in pixels from the end of the bottom axis to the right side of the component\n\nconst RIGHT_MARGIN = 10; // The distance in pixels from the top of the component to the top of the y axis\n\nconst TOP_MARGIN = 10;\nconst BOTTOM_MARGIN = 20; //padding in between each bar as a percent of the bar width\n\nconst BAR_PADDING = 0.2; // the padding to the left of the left axis in pixels\n\nconst GraphContainer = styled.div.withConfig({\n  displayName: \"TimeGraph__GraphContainer\",\n  componentId: \"sc-18irejk-0\"\n})([\"position:relative;& .popularTimes__bar{cursor:pointer;}\"]);\nexport default function TimeGraph({\n  values,\n  maxTime,\n  firstHour,\n  lastHour,\n  width,\n  height\n}) {\n  const {\n    tooltipOpen,\n    tooltipLeft,\n    tooltipTop,\n    tooltipData,\n    hideTooltip,\n    showTooltip\n  } = useTooltip();\n  const {\n    containerRef,\n    TooltipInPortal\n  } = useTooltipInPortal(); // bounds\n\n  const xMax = width - RIGHT_MARGIN - LEFT_MARGIN;\n  const yMax = height - TOP_MARGIN - BOTTOM_MARGIN; // scales, memoize for performance\n\n  const xScale = useMemo(() => scaleBand({\n    range: [0, xMax],\n    round: true,\n    domain: range(Math.max(0, firstHour), Math.min(lastHour + 1, 24) + 1),\n    padding: BAR_PADDING\n  }), [xMax, firstHour, lastHour]); // number of minutes between each grid row line\n\n  const gridRowInterval = maxTime >= 60 ? 60 : 30;\n  const maxTickVal = Math.max(maxTime, gridRowInterval);\n  const yScale = useMemo(() => scaleLinear({\n    range: [yMax, 0],\n    round: true,\n    domain: [0, maxTickVal + 5]\n  }), [yMax, maxTickVal]);\n  const barWidth = xScale.bandwidth(); // the tick values for the y axis\n\n  const yAxisTickValues = range(gridRowInterval, maxTickVal + 1, gridRowInterval);\n  return width < 10 ? null : // relative position is needed for correct tooltip positioning\n  __jsx(GraphContainer, null, __jsx(\"svg\", {\n    ref: containerRef,\n    width: width,\n    height: height\n  }, __jsx(\"rect\", {\n    x: 0,\n    y: 0,\n    width: width,\n    height: height,\n    fill: \"rgba(0,0,0,0)\",\n    rx: 14\n  }), __jsx(GridRows, {\n    top: TOP_MARGIN,\n    left: LEFT_MARGIN,\n    width: width - RIGHT_MARGIN - LEFT_MARGIN,\n    scale: yScale,\n    tickValues: yAxisTickValues,\n    stroke: \"#cccccc\"\n  }), __jsx(Group, {\n    left: LEFT_MARGIN,\n    top: TOP_MARGIN\n  }, values.map((value, i) => {\n    const barHeight = yMax - yScale(value);\n    const barX = xScale(i) + barWidth * (1 + BAR_PADDING) / 2;\n    const barY = yMax - barHeight;\n\n    const interactWithBar = () => {\n      if (tooltipTimeout) clearTimeout(tooltipTimeout);\n      const top = yMax - barHeight - TOP_MARGIN; // - VERTICAL_MARGIN - barHeight;\n\n      const left = barX + barWidth;\n      showTooltip({\n        tooltipData: value,\n        tooltipTop: top,\n        tooltipLeft: left\n      });\n    };\n\n    return __jsx(BarRounded, {\n      key: `bar-${formatDateHour(i)}`,\n      className: \"popularTimes__bar\",\n      x: barX,\n      y: barY,\n      width: barWidth,\n      height: barHeight,\n      radius: 10,\n      top: true,\n      fill: \"#40a9ff\",\n      onMouseLeave: () => {\n        tooltipTimeout = window.setTimeout(() => {\n          hideTooltip();\n        }, 300);\n      },\n      onMouseOver: interactWithBar,\n      onMouseDown: interactWithBar\n    });\n  })), __jsx(Group, {\n    left: LEFT_MARGIN\n  }, __jsx(AxisBottom, {\n    top: yMax + TOP_MARGIN,\n    scale: xScale,\n    tickFormat: hour => (hour - firstHour) % 3 == 0 ? formatDateHour(hour) : \"\",\n    tickLabelProps: () => ({\n      fill: \"\",\n      fontSize: 11,\n      textAnchor: \"middle\"\n    })\n  })), __jsx(Group, {\n    top: TOP_MARGIN,\n    left: LEFT_MARGIN\n  }, __jsx(AxisLeft, {\n    scale: yScale,\n    hideTicks: true,\n    tickValues: yAxisTickValues,\n    tickFormat: hour => formatWaitTime(hour),\n    tickLabelProps: () => ({\n      fill: \"\",\n      fontSize: 11,\n      textAnchor: \"end\"\n    })\n  }))), tooltipOpen && tooltipData && __jsx(TooltipInPortal, {\n    key: Math.random() // update tooltip bounds each render\n    ,\n    top: tooltipTop,\n    left: tooltipLeft,\n    style: tooltipStyles\n  }, formatWaitTime(tooltipData)));\n}","map":null,"metadata":{},"sourceType":"module"}