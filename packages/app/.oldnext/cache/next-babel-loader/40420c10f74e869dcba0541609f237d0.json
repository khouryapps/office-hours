{"ast":null,"code":"import { useEffect, useState } from \"react\";\nimport ReconnectingEventSource from \"reconnecting-eventsource\";\nvar EVENTSOURCES = {};\n/**\n * Listen to eventsource at given url calling the given onmessage when messages are received.\n * onmessage is overwritten if listenerKey is the same.\n * Returns whether the event source is connected\n * @param url URL to subscribe event source to\n * @param listenerKey key of the listener. eg: \"queue\" or \"question\"\n * @param onmessage callback when messages are received\n */\n\nexport var useEventSource = function useEventSource(url, listenerKey, onmessage) {\n  var _useState = useState(false),\n      isLive = _useState[0],\n      setIsLive = _useState[1];\n\n  useEffect(function () {\n    if (url) {\n      var source;\n\n      if (url in EVENTSOURCES) {\n        source = EVENTSOURCES[url];\n      } else {\n        source = {\n          eventSource: new ReconnectingEventSource(url),\n          listeners: {},\n          isLiveSetters: new Set()\n        };\n        EVENTSOURCES[url] = source;\n\n        source.eventSource.onmessage = function logEvents(event) {\n          var values = Object.values(source.listeners);\n          var eventData = JSON.parse(event.data);\n          values.forEach(function (lac) {\n            return lac.listener(eventData);\n          });\n        };\n\n        source.eventSource.onopen = function () {\n          return source.isLiveSetters.forEach(function (set) {\n            return set(true);\n          });\n        };\n\n        source.eventSource.onerror = function () {\n          return source.isLiveSetters.forEach(function (set) {\n            return set(false);\n          });\n        };\n      }\n\n      setIsLive(source.eventSource.readyState === EventSource.OPEN);\n      source.isLiveSetters.add(setIsLive);\n      var listener = source.listeners[listenerKey];\n\n      if (source.listeners[listenerKey]) {\n        listener.count++;\n      } else {\n        listener = {\n          listener: onmessage,\n          count: 1\n        };\n        source.listeners[listenerKey] = listener;\n      }\n\n      return function () {\n        // Close event source if no one is listening\n        listener.count--;\n        source.isLiveSetters[\"delete\"](setIsLive);\n\n        if (listener.count === 0) {\n          delete source.listeners[listenerKey];\n\n          if (Object.values(source.listeners).length === 0) {\n            source.eventSource.close();\n            delete EVENTSOURCES[url];\n          }\n        }\n      };\n    }\n  }, [url, onmessage, listenerKey]);\n  return isLive;\n};","map":{"version":3,"sources":["/home/runner/work/office-hours/office-hours/packages/app/hooks/useEventSource.ts"],"names":["useEffect","useState","ReconnectingEventSource","EVENTSOURCES","useEventSource","url","listenerKey","onmessage","isLive","setIsLive","source","eventSource","listeners","isLiveSetters","Set","logEvents","event","values","Object","eventData","JSON","parse","data","forEach","lac","listener","onopen","set","onerror","readyState","EventSource","OPEN","add","count","length","close"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\";\nimport ReconnectingEventSource from \"reconnecting-eventsource\";\n\ninterface ListenerAndCount {\n  listener: (d: any) => void;\n  count: number;\n}\n\ninterface SourceAndCount {\n  eventSource: EventSource;\n  listeners: Record<string, ListenerAndCount>;\n  isLiveSetters: Set<(live: boolean) => void>;\n}\nconst EVENTSOURCES: Record<string, SourceAndCount> = {};\n\n/**\n * Listen to eventsource at given url calling the given onmessage when messages are received.\n * onmessage is overwritten if listenerKey is the same.\n * Returns whether the event source is connected\n * @param url URL to subscribe event source to\n * @param listenerKey key of the listener. eg: \"queue\" or \"question\"\n * @param onmessage callback when messages are received\n */\nexport const useEventSource = (\n  url: string,\n  listenerKey: string,\n  onmessage: (d: any) => void\n): boolean => {\n  const [isLive, setIsLive] = useState<boolean>(false);\n  useEffect(() => {\n    if (url) {\n      let source: SourceAndCount;\n      if (url in EVENTSOURCES) {\n        source = EVENTSOURCES[url];\n      } else {\n        source = {\n          eventSource: new ReconnectingEventSource(url),\n          listeners: {},\n          isLiveSetters: new Set(),\n        };\n        EVENTSOURCES[url] = source;\n        source.eventSource.onmessage = function logEvents(event) {\n          const values = Object.values(source.listeners);\n          const eventData = JSON.parse(event.data);\n          values.forEach((lac) => lac.listener(eventData));\n        };\n        source.eventSource.onopen = () =>\n          source.isLiveSetters.forEach((set) => set(true));\n        source.eventSource.onerror = () =>\n          source.isLiveSetters.forEach((set) => set(false));\n      }\n\n      setIsLive(source.eventSource.readyState === EventSource.OPEN);\n      source.isLiveSetters.add(setIsLive);\n\n      let listener = source.listeners[listenerKey];\n\n      if (source.listeners[listenerKey]) {\n        listener.count++;\n      } else {\n        listener = { listener: onmessage, count: 1 };\n        source.listeners[listenerKey] = listener;\n      }\n\n      return () => {\n        // Close event source if no one is listening\n        listener.count--;\n        source.isLiveSetters.delete(setIsLive);\n        if (listener.count === 0) {\n          delete source.listeners[listenerKey];\n          if (Object.values(source.listeners).length === 0) {\n            source.eventSource.close();\n            delete EVENTSOURCES[url];\n          }\n        }\n      };\n    }\n  }, [url, onmessage, listenerKey]);\n\n  return isLive;\n};\n"]},"metadata":{},"sourceType":"module"}