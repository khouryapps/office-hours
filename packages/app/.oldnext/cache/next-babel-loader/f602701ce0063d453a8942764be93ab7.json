{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { API } from \"@koh/api-client\";\nimport { GetQueueResponse } from \"@koh/common\";\nimport useSWR, { mutate } from \"swr\";\nimport { useCallback, useEffect } from \"react\";\nimport { useEventSource } from \"./useEventSource\";\nimport { plainToClass } from \"class-transformer\";\n// Keep track of all the different Refresh information and callbacks.\n// This is a global because useQueue can be used multiple times, but SWR's onSuccess overwrites other instances\nvar REFRESH_INFO = {};\n/**\n * Notify all onUpdate subscribers that new data came in.\n */\n\nfunction callOnUpdates(key) {\n  var refreshInfo = REFRESH_INFO[key];\n  refreshInfo.onUpdates.forEach(function (cb) {\n    return cb(refreshInfo.lastUpdated);\n  });\n}\n/**\n * Get data for a queue.\n * @param qid Queue ID to get data for\n * @param onUpdate Optional callback to listen for when data is refetched, whether via HTTP or SSE\n */\n\n\nexport function useQueue(qid, onUpdate) {\n  var key = qid && \"/api/v1/queues/\".concat(qid);\n\n  if (!(key in REFRESH_INFO)) {\n    REFRESH_INFO[key] = {\n      lastUpdated: null,\n      onUpdates: new Set()\n    };\n  } // Register onUpdate callback\n\n\n  useEffect(function () {\n    if (onUpdate) {\n      var refreshInfo = REFRESH_INFO[key];\n      refreshInfo.onUpdates.add(onUpdate);\n      onUpdate(refreshInfo.lastUpdated);\n      return function () {\n        return refreshInfo.onUpdates[\"delete\"](onUpdate);\n      };\n    }\n  }, [onUpdate, key]);\n  var isLive = useEventSource(qid && \"/api/v1/queues/\".concat(qid, \"/sse\"), \"queue\", useCallback(function (data) {\n    if (data.queue) {\n      mutate(key, plainToClass(GetQueueResponse, data.queue), false);\n      REFRESH_INFO[key].lastUpdated = new Date();\n      callOnUpdates(key);\n    }\n  }, [key]));\n\n  var _useSWR = useSWR(key, useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", API.queues.get(Number(qid)));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [qid]), {\n    refreshInterval: isLive ? 0 : 10 * 1000,\n    onSuccess: function onSuccess(_, key) {\n      REFRESH_INFO[key].lastUpdated = new Date();\n      callOnUpdates(key);\n    }\n  }),\n      queue = _useSWR.data,\n      queueError = _useSWR.error,\n      mutateQueue = _useSWR.mutate;\n\n  return {\n    queue: queue,\n    queueError: queueError,\n    mutateQueue: mutateQueue,\n    isLive: isLive\n  };\n}","map":{"version":3,"sources":["/home/runner/work/office-hours/office-hours/packages/app/hooks/useQueue.ts"],"names":["API","GetQueueResponse","useSWR","mutate","useCallback","useEffect","useEventSource","plainToClass","REFRESH_INFO","callOnUpdates","key","refreshInfo","onUpdates","forEach","cb","lastUpdated","useQueue","qid","onUpdate","Set","add","isLive","data","queue","Date","queues","get","Number","refreshInterval","onSuccess","_","queueError","error","mutateQueue"],"mappings":"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","sourcesContent":["import { API } from \"@koh/api-client\";\nimport { GetQueueResponse, QueuePartial, SSEQueueResponse } from \"@koh/common\";\nimport useSWR, { mutate, responseInterface } from \"swr\";\nimport { useCallback, useEffect } from \"react\";\nimport { useEventSource } from \"./useEventSource\";\nimport { plainToClass } from \"class-transformer\";\n\ntype queueResponse = responseInterface<QueuePartial, any>;\n\ninterface UseQueueReturn {\n  queue?: queueResponse[\"data\"];\n  queueError: queueResponse[\"error\"];\n  mutateQueue: queueResponse[\"mutate\"];\n  isLive: boolean;\n}\n\ntype OnUpdate = (lastUpdated: Date) => void;\n\ninterface RefreshInfo {\n  lastUpdated: Date;\n  onUpdates: Set<OnUpdate>;\n}\n\n// Keep track of all the different Refresh information and callbacks.\n// This is a global because useQueue can be used multiple times, but SWR's onSuccess overwrites other instances\nconst REFRESH_INFO: Record<string, RefreshInfo> = {};\n\n/**\n * Notify all onUpdate subscribers that new data came in.\n */\nfunction callOnUpdates(key: string) {\n  const refreshInfo = REFRESH_INFO[key];\n  refreshInfo.onUpdates.forEach((cb) => cb(refreshInfo.lastUpdated));\n}\n\n/**\n * Get data for a queue.\n * @param qid Queue ID to get data for\n * @param onUpdate Optional callback to listen for when data is refetched, whether via HTTP or SSE\n */\nexport function useQueue(qid: number, onUpdate?: OnUpdate): UseQueueReturn {\n  const key = qid && `/api/v1/queues/${qid}`;\n  if (!(key in REFRESH_INFO)) {\n    REFRESH_INFO[key] = {\n      lastUpdated: null,\n      onUpdates: new Set(),\n    };\n  }\n\n  // Register onUpdate callback\n  useEffect(() => {\n    if (onUpdate) {\n      const refreshInfo = REFRESH_INFO[key];\n      refreshInfo.onUpdates.add(onUpdate);\n      onUpdate(refreshInfo.lastUpdated);\n      return () => refreshInfo.onUpdates.delete(onUpdate);\n    }\n  }, [onUpdate, key]);\n\n  const isLive = useEventSource(\n    qid && `/api/v1/queues/${qid}/sse`,\n    \"queue\",\n    useCallback(\n      (data: SSEQueueResponse) => {\n        if (data.queue) {\n          mutate(key, plainToClass(GetQueueResponse, data.queue), false);\n          REFRESH_INFO[key].lastUpdated = new Date();\n          callOnUpdates(key);\n        }\n      },\n      [key]\n    )\n  );\n\n  const { data: queue, error: queueError, mutate: mutateQueue } = useSWR(\n    key,\n    useCallback(async () => API.queues.get(Number(qid)), [qid]),\n    {\n      refreshInterval: isLive ? 0 : 10 * 1000,\n      onSuccess: (_, key) => {\n        REFRESH_INFO[key].lastUpdated = new Date();\n        callOnUpdates(key);\n      },\n    }\n  );\n\n  return {\n    queue,\n    queueError,\n    mutateQueue,\n    isLive,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}