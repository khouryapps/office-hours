{"ast":null,"code":"import _regeneratorRuntime from \"/var/www/source/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/var/www/source/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { API } from \"@koh/api-client\";\nimport { GetQueueResponse } from \"@koh/common\";\nimport useSWR, { mutate } from \"swr\";\nimport { useCallback, useEffect } from \"react\";\nimport { useEventSource } from \"./useEventSource\";\nimport { plainToClass } from \"class-transformer\";\n// Keep track of all the different Refresh information and callbacks.\n// This is a global because useQueue can be used multiple times, but SWR's onSuccess overwrites other instances\nvar REFRESH_INFO = {};\n/**\n * Notify all onUpdate subscribers that new data came in.\n */\n\nfunction callOnUpdates(key) {\n  var refreshInfo = REFRESH_INFO[key];\n  refreshInfo.onUpdates.forEach(function (cb) {\n    return cb(refreshInfo.lastUpdated);\n  });\n}\n/**\n * Get data for a queue.\n * @param qid Queue ID to get data for\n * @param onUpdate Optional callback to listen for when data is refetched, whether via HTTP or SSE\n */\n\n\nexport function useQueue(qid, onUpdate) {\n  var key = qid && \"/api/v1/queues/\".concat(qid);\n\n  if (!(key in REFRESH_INFO)) {\n    REFRESH_INFO[key] = {\n      lastUpdated: null,\n      onUpdates: new Set()\n    };\n  } // Register onUpdate callback\n\n\n  useEffect(function () {\n    if (onUpdate) {\n      var refreshInfo = REFRESH_INFO[key];\n      refreshInfo.onUpdates.add(onUpdate);\n      onUpdate(refreshInfo.lastUpdated);\n      return function () {\n        refreshInfo.onUpdates[\"delete\"](onUpdate);\n      };\n    }\n  }, [onUpdate, key]);\n  var isLive = useEventSource(qid && \"/api/v1/queues/\".concat(qid, \"/sse\"), \"queue\", useCallback(function (data) {\n    if (data.queue) {\n      mutate(key, plainToClass(GetQueueResponse, data.queue), false);\n      REFRESH_INFO[key].lastUpdated = new Date();\n      callOnUpdates(key);\n    }\n  }, [key]));\n\n  var _useSWR = useSWR(key, useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", API.queues.get(Number(qid)));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [qid]), {\n    refreshInterval: isLive ? 0 : 10 * 1000,\n    onSuccess: function onSuccess(_, key) {\n      REFRESH_INFO[key].lastUpdated = new Date();\n      callOnUpdates(key);\n    }\n  }),\n      queue = _useSWR.data,\n      queueError = _useSWR.error,\n      mutateQueue = _useSWR.mutate;\n\n  return {\n    queue: queue,\n    queueError: queueError,\n    mutateQueue: mutateQueue,\n    isLive: isLive\n  };\n}","map":null,"metadata":{},"sourceType":"module"}