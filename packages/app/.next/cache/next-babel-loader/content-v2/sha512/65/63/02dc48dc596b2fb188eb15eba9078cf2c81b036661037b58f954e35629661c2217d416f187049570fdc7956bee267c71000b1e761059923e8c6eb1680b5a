{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { API } from \"@koh/api-client\";\nimport { ClosedQuestionStatus, ERROR_MESSAGES, LimboQuestionStatus, OpenQuestionStatus } from \"@koh/common\";\nimport { Card, Col, notification, Popconfirm, Row } from \"antd\";\nimport { useRouter } from \"next/router\";\nimport React, { useCallback, useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport { mutate } from \"swr\";\nimport { useDraftQuestion } from \"../../../hooks/useDraftQuestion\";\nimport { useLocalStorage } from \"../../../hooks/useLocalStorage\";\nimport { useQuestions } from \"../../../hooks/useQuestions\";\nimport { useQueue } from \"../../../hooks/useQueue\";\nimport { useStudentQuestion } from \"../../../hooks/useStudentQuestion\";\nimport { QueueInfoColumn, QueueInfoColumnButton } from \"../QueueListSharedComponents\";\nimport QuestionForm from \"./QuestionForm\";\nimport StudentBanner from \"./StudentBanner\";\nimport CantFindModal from \"./StudentCantFindModal\";\nimport StudentQueueCard from \"./StudentQueueCard\";\nimport StudentRemovedFromQueueModal from \"./StudentRemovedFromQueueModal\";\nconst Container = styled.div.withConfig({\n  displayName: \"StudentQueue__Container\",\n  componentId: \"sc-1qu48se-0\"\n})([\"flex:1;display:flex;flex-direction:column;margin-top:10px;@media (min-width:650px){margin-top:0;flex-direction:row;height:100%;}\"]);\nconst QueueListContainer = styled.div.withConfig({\n  displayName: \"StudentQueue__QueueListContainer\",\n  componentId: \"sc-1qu48se-1\"\n})([\"flex-grow:1;@media (min-width:650px){margin-top:32px;}\"]);\nconst JoinButton = styled(QueueInfoColumnButton).withConfig({\n  displayName: \"StudentQueue__JoinButton\",\n  componentId: \"sc-1qu48se-2\"\n})([\"background-color:#3684c6;color:white;\"]);\nconst VerticalDivider = styled.div.withConfig({\n  displayName: \"StudentQueue__VerticalDivider\",\n  componentId: \"sc-1qu48se-3\"\n})([\"@media (min-width:650px){border-right:1px solid #cfd6de;margin:0 16px;}@media (min-width:1000px){margin:0 32px;}\"]);\nconst StudentHeaderCard = styled(Card).withConfig({\n  displayName: \"StudentQueue__StudentHeaderCard\",\n  componentId: \"sc-1qu48se-4\"\n})([\"height:64px;padding-left:8px;padding-right:8px;background:inherit;\"]);\nconst HeaderText = styled.div.withConfig({\n  displayName: \"StudentQueue__HeaderText\",\n  componentId: \"sc-1qu48se-5\"\n})([\"font-size:14px;font-weight:500;line-height:22px;color:#8895a6;font-variant:small-caps;\"]);\nconst PopConfirmTitle = styled.div.withConfig({\n  displayName: \"StudentQueue__PopConfirmTitle\",\n  componentId: \"sc-1qu48se-6\"\n})([\"max-width:400px;\"]);\nconst CenterRow = styled(Row).withConfig({\n  displayName: \"StudentQueue__CenterRow\",\n  componentId: \"sc-1qu48se-7\"\n})([\"align-items:center;\"]);\nexport default function StudentQueue({\n  qid,\n  cid\n}) {\n  const {\n    queue\n  } = useQueue(qid);\n  const {\n    questions,\n    mutateQuestions\n  } = useQuestions(qid);\n  const {\n    studentQuestion,\n    studentQuestionIndex\n  } = useStudentQuestion(qid);\n  const [isFirstQuestion, setIsFirstQuestion] = useLocalStorage(\"isFirstQuestion\", true);\n  const {\n    0: showJoinPopconfirm,\n    1: setShowJoinPopconfirm\n  } = useState(false);\n  const {\n    deleteDraftQuestion\n  } = useDraftQuestion();\n  const {\n    0: isJoining,\n    1: setIsJoining\n  } = useState(questions && studentQuestion && (studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.status) !== OpenQuestionStatus.Queued);\n  const {\n    0: popupEditQuestion,\n    1: setPopupEditQuestion\n  } = useState(false);\n  const router = useRouter();\n  const editQuestionQueryParam = Boolean(router.query.edit_question);\n  useEffect(() => {\n    if (editQuestionQueryParam && studentQuestion) {\n      mutate(`/api/v1/queues/${qid}/questions`);\n      setPopupEditQuestion(true);\n      router.push(`/course/${cid}/queue/${qid}`);\n    }\n  }, [editQuestionQueryParam, qid, studentQuestion]);\n  const studentQuestionId = studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.id;\n  const studentQuestionStatus = studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.status;\n  const leaveQueue = useCallback(async () => {\n    await API.questions.update(studentQuestionId, {\n      status: ClosedQuestionStatus.ConfirmedDeleted\n    });\n    setIsJoining(false);\n    await mutateQuestions();\n  }, [mutateQuestions, studentQuestionId]);\n  const rejoinQueue = useCallback(async () => {\n    await API.questions.update(studentQuestionId, {\n      status: OpenQuestionStatus.PriorityQueued\n    });\n    await mutateQuestions();\n  }, [mutateQuestions, studentQuestionId]);\n  const finishQuestion = useCallback(async (text, questionType, groupable) => {\n    var _questions$queue;\n\n    const updateStudent = {\n      text,\n      questionType,\n      groupable,\n      status: studentQuestionStatus === OpenQuestionStatus.Drafting ? OpenQuestionStatus.Queued : studentQuestionStatus\n    };\n    const updatedQuestionFromStudent = await API.questions.update(studentQuestionId, updateStudent);\n    const newQuestionsInQueue = questions === null || questions === void 0 ? void 0 : (_questions$queue = questions.queue) === null || _questions$queue === void 0 ? void 0 : _questions$queue.map(question => question.id === studentQuestionId ? updatedQuestionFromStudent : question); // questions are the old questions and newQuestionsInQueue are questions that've been added since.\n\n    mutateQuestions(_objectSpread(_objectSpread({}, questions), {}, {\n      yourQuestion: updatedQuestionFromStudent,\n      queue: newQuestionsInQueue\n    }));\n  }, [studentQuestionStatus, studentQuestionId, questions, mutateQuestions]);\n  const joinQueueAfterDeletion = useCallback(async () => {\n    await API.questions.update(studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.id, {\n      status: ClosedQuestionStatus.ConfirmedDeleted\n    });\n    await mutateQuestions();\n    const newQuestion = await API.questions.create({\n      text: studentQuestion.text,\n      questionType: studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.questionType,\n      queueId: qid,\n      location: studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.location,\n      force: true,\n      groupable: false\n    });\n    await API.questions.update(newQuestion.id, {\n      status: OpenQuestionStatus.Queued\n    });\n    await mutateQuestions();\n  }, [mutateQuestions, qid, studentQuestion]);\n  const openEditModal = useCallback(async () => {\n    mutate(`/api/v1/queues/${qid}/questions`);\n    setPopupEditQuestion(true);\n  }, [qid]);\n  const closeEditModal = useCallback(() => {\n    setPopupEditQuestion(false);\n    setIsJoining(false);\n  }, []);\n  const leaveQueueAndClose = useCallback(() => {\n    //delete draft when they leave the queue\n    deleteDraftQuestion();\n    leaveQueue();\n    closeEditModal();\n  }, [deleteDraftQuestion, leaveQueue, closeEditModal]);\n  const joinQueueOpenModal = useCallback(async force => {\n    try {\n      const createdQuestion = await API.questions.create({\n        queueId: Number(qid),\n        text: \"\",\n        force: force,\n        questionType: null,\n        groupable: false\n      });\n      const newQuestionsInQueue = [...(questions === null || questions === void 0 ? void 0 : questions.queue), createdQuestion];\n      await mutateQuestions(_objectSpread(_objectSpread({}, questions), {}, {\n        queue: newQuestionsInQueue\n      }));\n      setPopupEditQuestion(true);\n      return true;\n    } catch (e) {\n      var _e$response, _e$response$data, _e$response$data$mess;\n\n      if ((_e$response = e.response) !== null && _e$response !== void 0 && (_e$response$data = _e$response.data) !== null && _e$response$data !== void 0 && (_e$response$data$mess = _e$response$data.message) !== null && _e$response$data$mess !== void 0 && _e$response$data$mess.includes(ERROR_MESSAGES.questionController.createQuestion.oneQuestionAtATime)) {\n        return false;\n      }\n\n      return true; // TODO: how should we handle error that happens for another reason?\n    }\n  }, [mutateQuestions, qid, questions]);\n  const finishQuestionAndClose = useCallback((text, qt, groupable, router, cid) => {\n    deleteDraftQuestion();\n    finishQuestion(text, qt, groupable);\n    closeEditModal();\n\n    if (isFirstQuestion) {\n      notification.warn({\n        style: {\n          cursor: \"pointer\"\n        },\n        message: \"Enable Notifications\",\n        className: \"hide-in-percy\",\n        description: \"Turn on notifications for when it's almost your turn to get help.\",\n        placement: \"bottomRight\",\n        duration: 0,\n        onClick: () => {\n          notification.destroy();\n          setIsFirstQuestion(false);\n          router.push(`/settings?cid=${cid}`);\n        }\n      });\n    }\n  }, [deleteDraftQuestion, finishQuestion, closeEditModal, isFirstQuestion, setIsFirstQuestion]);\n\n  if (queue && questions) {\n    if (!queue.isOpen) {\n      return /*#__PURE__*/_jsx(\"h1\", {\n        style: {\n          marginTop: \"50px\"\n        },\n        children: \"The Queue is Closed!\"\n      });\n    }\n\n    return /*#__PURE__*/_jsxs(_Fragment, {\n      children: [/*#__PURE__*/_jsxs(Container, {\n        children: [/*#__PURE__*/_jsx(CantFindModal, {\n          visible: (studentQuestion === null || studentQuestion === void 0 ? void 0 : studentQuestion.status) === LimboQuestionStatus.CantFind,\n          leaveQueue: leaveQueue,\n          rejoinQueue: rejoinQueue\n        }), /*#__PURE__*/_jsx(StudentRemovedFromQueueModal, {\n          question: studentQuestion,\n          leaveQueue: leaveQueue,\n          joinQueue: joinQueueAfterDeletion\n        }), /*#__PURE__*/_jsx(QueueInfoColumn, {\n          queueId: qid,\n          isStaff: false,\n          buttons: !studentQuestion && /*#__PURE__*/_jsx(Popconfirm, {\n            title: /*#__PURE__*/_jsx(PopConfirmTitle, {\n              children: \"You already have a question in a queue for this course, so your previous question will be deleted in order to join this queue. Do you want to continue?\"\n            }),\n            onConfirm: () => joinQueueOpenModal(true),\n            okText: \"Yes\",\n            cancelText: \"No\",\n            disabled: true,\n            visible: showJoinPopconfirm,\n            onVisibleChange: setShowJoinPopconfirm,\n            children: /*#__PURE__*/_jsx(JoinButton, {\n              type: \"primary\",\n              disabled: !(queue !== null && queue !== void 0 && queue.allowQuestions) || (queue === null || queue === void 0 ? void 0 : queue.isDisabled),\n              \"data-cy\": \"join-queue-button\",\n              onClick: async () => setShowJoinPopconfirm(!(await joinQueueOpenModal(false))),\n              children: \"Join Queue\"\n            })\n          })\n        }), /*#__PURE__*/_jsx(VerticalDivider, {}), /*#__PURE__*/_jsxs(QueueListContainer, {\n          children: [studentQuestion && /*#__PURE__*/_jsxs(_Fragment, {\n            children: [/*#__PURE__*/_jsx(StudentBanner, {\n              queueId: qid,\n              editQuestion: openEditModal,\n              leaveQueue: leaveQueue\n            }), /*#__PURE__*/_jsx(\"div\", {\n              style: {\n                marginTop: \"40px\"\n              }\n            })]\n          }), /*#__PURE__*/_jsx(QueueQuestions, {\n            questions: questions === null || questions === void 0 ? void 0 : questions.queue,\n            studentQuestion: studentQuestion\n          })]\n        })]\n      }), /*#__PURE__*/_jsx(QuestionForm, {\n        visible: questions && !studentQuestion && isJoining || // && studentQuestion.status !== QuestionStatusKeys.Drafting)\n        popupEditQuestion,\n        question: studentQuestion,\n        leaveQueue: leaveQueueAndClose,\n        finishQuestion: finishQuestionAndClose,\n        position: studentQuestionIndex + 1,\n        cancel: closeEditModal\n      })]\n    });\n  } else {\n    return /*#__PURE__*/_jsx(\"div\", {});\n  }\n}\nconst QueueHeader = styled.h2.withConfig({\n  displayName: \"StudentQueue__QueueHeader\",\n  componentId: \"sc-1qu48se-8\"\n})([\"font-weight:500;font-size:24px;color:#212934;margin-bottom:0;\"]);\nconst NoQuestionsText = styled.div.withConfig({\n  displayName: \"StudentQueue__NoQuestionsText\",\n  componentId: \"sc-1qu48se-9\"\n})([\"font-weight:500;font-size:24px;color:#212934;\"]); // I think we could share this with the TA\n\nfunction QueueQuestions({\n  questions,\n  studentQuestion\n}) {\n  return /*#__PURE__*/_jsxs(\"div\", {\n    \"data-cy\": \"queueQuestions\",\n    children: [(questions === null || questions === void 0 ? void 0 : questions.length) === 0 ? /*#__PURE__*/_jsx(NoQuestionsText, {\n      children: \"There are no questions in the queue\"\n    }) : /*#__PURE__*/_jsxs(_Fragment, {\n      children: [/*#__PURE__*/_jsx(QueueHeader, {\n        children: \"Queue\"\n      }), /*#__PURE__*/_jsx(StudentHeaderCard, {\n        bordered: false,\n        children: /*#__PURE__*/_jsxs(CenterRow, {\n          children: [/*#__PURE__*/_jsx(Col, {\n            flex: \"0 0 64px\",\n            children: /*#__PURE__*/_jsx(HeaderText, {\n              children: \"#\"\n            })\n          }), /*#__PURE__*/_jsx(Col, {\n            flex: \"1 1\",\n            children: /*#__PURE__*/_jsx(HeaderText, {\n              children: \"question\"\n            })\n          }), /*#__PURE__*/_jsx(Col, {\n            flex: \"0 0 80px\",\n            children: /*#__PURE__*/_jsx(HeaderText, {\n              children: \"wait\"\n            })\n          })]\n        })\n      })]\n    }), questions === null || questions === void 0 ? void 0 : questions.map((question, index) => {\n      return /*#__PURE__*/_jsx(StudentQueueCard, {\n        rank: index + 1,\n        question: question,\n        highlighted: studentQuestion === question\n      }, question.id);\n    })]\n  });\n}","map":null,"metadata":{},"sourceType":"module"}